package main

import (
	"flag"
	"fmt"
	"strings"

	"github.com/joesonw/proto-tools/pkg/genutil"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"

	errors_pb "github.com/joesonw/proto-web/pbgo/errors"
	protoutil2 "github.com/joesonw/proto-web/pkg/protoutil"
)

var (
	pkgFmt    = protogen.GoImportPath("fmt")
	pkgStatus = protogen.GoImportPath("google.golang.org/grpc/status")
	pkgCode   = protogen.GoImportPath("google.golang.org/grpc/codes")
)

func main() {
	var (
		flags        flag.FlagSet
		importPrefix = flags.String("import_prefix", "", "prefix to prepend to import paths")
	)
	importRewriteFunc := func(importPath protogen.GoImportPath) protogen.GoImportPath {
		switch importPath {
		case "context", "fmt", "math":
			return importPath
		}
		if *importPrefix != "" {
			return protogen.GoImportPath(*importPrefix) + importPath
		}
		return importPath
	}
	protogen.Options{
		ParamFunc:         flags.Set,
		ImportRewriteFunc: importRewriteFunc,
	}.Run(func(gen *protogen.Plugin) error {
		for _, file := range gen.Files {
			if !file.Generate {
				continue
			}
			filename := file.GeneratedFilenamePrefix + "_errors.pb.go"
			g := genutil.New(gen.NewGeneratedFile(filename, file.GoImportPath), func(g *genutil.G) genutil.Generator {
				return protoutil2.GeneratorFunc(func() error {
					g.P("// Code generated by protoc-gen-pw-errors. DO NOT EDIT. ")
					g.P("package ", file.GoPackageName)
					g.P("")
					var process func(message *protogen.Message) error
					process = func(m *protogen.Message) error {
						for _, message := range m.Messages {
							if err := process(message); err != nil {
								return err
							}
						}

						grpcCode,_ := proto.GetExtension(m.Desc.Options(), errors_pb.E_GrpcCode).(int32)
						httpStatus, _ := proto.GetExtension(m.Desc.Options(), errors_pb.E_HttpStatus).(int32)
						temporary, _ := proto.GetExtension(m.Desc.Options(), errors_pb.E_Temporary).(bool)
						fatal, _ := proto.GetExtension(m.Desc.Options(), errors_pb.E_Fatal).(bool)
						format, _ := proto.GetExtension(m.Desc.Options(), errors_pb.E_Format).(string)

						if temporary && fatal {
							return fmt.Errorf("message %s cannot be both fatal and temporary", m.Desc.Name())
						}

						if grpcCode != 0{
							g.F("func (x *%s) GRPCStatus() *%s {", m.GoIdent.GoName, pkgStatus.Ident("Status"))
							g.F("return %s(%s(%d), x.Error())", pkgStatus.Ident("New"), pkgCode.Ident("Code"), grpcCode)
							g.P("}")
							g.P("")
						}
						if httpStatus != 0 {
							g.F("func (x *%s) HTTPStatus() int {", m.GoIdent.GoName)
							g.F("return %d", httpStatus)
							g.P("}")
							g.P("")
						}
						if temporary {
							g.F("func (x *%s) Temporary() {}", m.GoIdent.GoName)
							g.P("")
						}
						if fatal {
							g.F("func (x *%s) Fatal() {}", m.GoIdent.GoName)
							g.P("")
						}
						args := make([]string, len(m.Fields))
						for i := range m.Fields {
							args[i] = "x." + string(m.Fields[i].GoName)
						}
						g.F("func (x *%s) Error() string { ", m.GoIdent.GoName)
						if format != "" {
							g.F("return %s(\"%s\", %s)", pkgFmt.Ident("Sprintf"), format, strings.Join(args, ", "))
							g.P("}")
						} else {
							names := make([]string, len(m.Fields))
							for i := range m.Fields {
								names[i] = string(m.Fields[i].Desc.Name()) + " = %s"
							}
							g.F("return %s(\"%sError: %s\", %s)", pkgFmt.Ident("Sprintf"), m.GoIdent.GoName, strings.Join(names, ", "), strings.Join(args, ", "))
							g.P("}")
						}
						g.P("")

						return nil
					}

					for _, message := range file.Messages {
						if err := process(message); err != nil {
							return err
						}
					}

					return nil
				})
			})
			if err := g.Generate(); err != nil {
				return err
			}
		}
		return nil
	})
}
