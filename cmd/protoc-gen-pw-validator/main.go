package main

import (
	"flag"
	"strings"

	"github.com/joesonw/proto-tools/pkg/genutil"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	validator_pb "github.com/joesonw/proto-web/pbgo/validator"
	protoutil2 "github.com/joesonw/proto-web/pkg/protoutil"
)

var (
	pkgValidator = protogen.GoImportPath("github.com/joesonw/proto-web/pkg/validator")
)

func main() {
	var (
		flags        flag.FlagSet
		importPrefix = flags.String("import_prefix", "", "prefix to prepend to import paths")
	)
	importRewriteFunc := func(importPath protogen.GoImportPath) protogen.GoImportPath {
		switch importPath {
		case "context", "fmt", "math":
			return importPath
		}
		if *importPrefix != "" {
			return protogen.GoImportPath(*importPrefix) + importPath
		}
		return importPath
	}
	protogen.Options{
		ParamFunc:         flags.Set,
		ImportRewriteFunc: importRewriteFunc,
	}.Run(func(gen *protogen.Plugin) error {
		for _, file := range gen.Files {
			if !file.Generate {
				continue
			}
			filename := file.GeneratedFilenamePrefix + "_validator.pb.go"
			g := genutil.New(gen.NewGeneratedFile(filename, file.GoImportPath), func(g *genutil.G) genutil.Generator {
				return protoutil2.GeneratorFunc(func() error {
					g.P("// Code generated by protoc-gen-pw-validator. DO NOT EDIT. ")
					g.P("package ", file.GoPackageName)
					g.P("")
					var process func(message *protogen.Message) error
					process = func(m *protogen.Message) error {
						for _, message := range m.Messages {
							if err := process(message); err != nil {
								return err
							}
						}

						if !isValidated(m) {
							return nil
						}

						g.F("func (x *%s) Validate() error {", m.GoIdent)

						for _, field := range m.Fields {
							var tags []string
							hasTags := false
							if field.Desc.IsList() || field.Desc.IsMap() {
								tags = append(tags, "dive")
							}

							if field.Desc.Kind() == protoreflect.MessageKind {
								if !isValidated(field.Message) {
									continue
								}
								if field.Desc.IsList() {
									g.F("for x2 := range x.%s {", field.GoName)
									g.F("if err := x2.Validate(); err != nil {")
									g.P("return err")
									g.P("}")
									g.F("}")
								} else {
									g.F("if err := x.%s.Validate(); err != nil {", field.GoName)
									g.P("return err")
									g.P("}")
								}
								continue
							}

							custom := getExtension(field.Desc.Options(), validator_pb.E_Custom)
							if custom != nil {
								hasTags = true
								tags = append(tags, custom.(string))
							}
							required := getExtension(field.Desc.Options(), validator_pb.E_Required)
							if required != nil && required.(bool) {
								hasTags = true
								tags = append(tags, "required")
							}
							oMax := getExtension(field.Desc.Options(), validator_pb.E_Max)
							if oMax != nil {
								hasTags = true
								tags = append(tags, "max="+oMax.(string))
							}
							oMin := getExtension(field.Desc.Options(), validator_pb.E_Min)
							if oMin != nil {
								hasTags = true
								tags = append(tags, "min="+oMin.(string))
							}
							oLen := getExtension(field.Desc.Options(), validator_pb.E_Len)
							if oLen != nil {
								hasTags = true
								tags = append(tags, "len="+oLen.(string))
							}
							eq := getExtension(field.Desc.Options(), validator_pb.E_Eq)
							if eq != nil {
								hasTags = true
								tags = append(tags, "eq="+eq.(string))
							}
							ne := getExtension(field.Desc.Options(), validator_pb.E_Ne)
							if ne != nil {
								hasTags = true
								tags = append(tags, "ne="+ne.(string))
							}
							gt := getExtension(field.Desc.Options(), validator_pb.E_Gt)
							if gt != nil {
								hasTags = true
								tags = append(tags, "gt="+gt.(string))
							}
							gte := getExtension(field.Desc.Options(), validator_pb.E_Gte)
							if gte != nil {
								hasTags = true
								tags = append(tags, "gte="+gte.(string))
							}
							lt := getExtension(field.Desc.Options(), validator_pb.E_Lt)
							if lt != nil {
								hasTags = true
								tags = append(tags, "lt="+lt.(string))
							}
							lte := getExtension(field.Desc.Options(), validator_pb.E_Lte)
							if lte != nil {
								hasTags = true
								tags = append(tags, "lte="+lte.(string))
							}

							if !hasTags {
								continue
							}

							g.F("if err := %s(x.%s, \"%s\"); err != nil {", pkgValidator.Ident("Var"), field.GoName, strings.Join(tags, ","))
							g.P("return err")
							g.P("}")
						}

						g.P("return nil")
						g.P("}")

						return nil
					}

					for _, message := range file.Messages {
						if err := process(message); err != nil {
							return err
						}
					}

					return nil
				})
			})
			if err := g.Generate(); err != nil {
				return err
			}
		}
		return nil
	})
}

func isValidated(m *protogen.Message) bool {
	validated, _ := getExtension(m.Desc.Options(), validator_pb.E_Validated).(bool)
	return validated
}

func getExtension(m proto.Message, xt protoreflect.ExtensionType) interface{} {
	if !proto.HasExtension(m, xt) {
		return nil
	}
	return proto.GetExtension(m, xt)
}
